1、数组
    (1) Arrays.binarySearch(一维数组名，要查找的值value)：  返回是下标，要求被查找的一维数组必须是有序的，否则结果是错误的
    (2) Arrays.copyOf(原一维数组名，新数组的长度)：  得到一个新的数组，需要接收，新数组的长度可以<,>,=原数组的长度，从原数组的[0]开始复制
    (3) Arrays.copyOfRange(原一维数组名, from ,to)：  得到一个新的数组，需要接收，新数组的长度可以<,>,=原数组的长度，从原数组的[from]开始复制
            from的值必须在原数组的下标范围内，to的值可以在原数组的下标范围外，新数组的长度是to - from，右边不包含！
    (4) Arrays.sort(一维数组名)：  实现从小到大排序
    (5) Arrays.toString(一维数组名)：  把一维数组的元素，拼接为一个字符串，[元素1，元素2，...]
    (6) Arrays.fill(一维数组名，填充的值value)：  把一维数组的每一个元素都填充为value，之前有的元素也替换，和sort一样单列一行就行，不用接收
    (7) Arrays.fill(一维数组名，from，to， 填充的值value)：  把一维数组的[from,to)的元素都填充为value，右边边界不包含。左右都不能越界
    (8) System.arraycopy(一维数组名，复制的起始位置，目标一维数组名，粘贴过来的起始位置，复制长度)，删除下标index元素：System.arraycopy(team,index+1,team,index, length-index-1);
    (9) Arrays.asList(1, 2, "hello", "world", "java")：  返回一个List集合  List<? extends Serializable>  ，只读的，不可更改了
2、Object
    （1） public boolean equals(Object obj)：做比较。区别：==和equals
            如果子类没重写equals()方法，那么Object默认的equals方法的实现，和“==”是一样的。
            如果子类希望equals()比较的不是对象的地址，而是其他信息，例如：属性的值等，那么就要重写equals方法。例如：String等都是重写了equals方法
    （2） public int hashCode()：返回哈希值，例子用int接受的，equals和hashCode方法一般形影不离，总是同时被重写
    （3） public Class getClass()：返回某个对象的运行时类型（个人理解包名.属性/类）
    （4） protected void finalize()：方法名object子类：这个方法是由GC（垃圾回收程序）调用，不是由程序员调用。
            System.gc();//这个通知垃圾回收器过来回收，但是实际什么时候来，还要看他自己的安排
    （5） public String toString()：   //打印输出方法sout调用
    （6） <clint>         //类静态加载方法
    （7） <init>          //类初始化方法
    (8) Comparable<T>   //自然比较规则、默认比较规则，一般类继承它，然后重写 comparaTo() 即可完成定制比较
    (9) comparaTo()     //Comparable的比较规则
    (10) Comparator<T>  //定制比较器，抽象方法compare
    (11) compare        //Comparator的比较规则
3、包装类
    （1） new Integer(int的值)：
    （2） Integer.parseInt(字符串)：将字符串转化为数字
    （3） Integer.valueOf(字符串)：将字符串转化为数字
    （4） String.valueOf(int的值)：将int值转为字符串
    （5） Integer.MAX_VALUE、Integer.MIN_VALUE：Integer类型最大最小值
    （6） Integer.toHexString(125)：//十进制转成十六进制
    （7） Integer.toOctalString(125)：//十进制转成八进制
    （8） Integer.toBinaryString(125)：//十进制转成二进制
    （9） Character.toUpperCase(字符)：//字符转成大写
    （10） Character.toLowerCase(字符)：//字符转成小写
4、字符串
    一、字符串操作
        (1) length()：求字符串的长度			//String s = null； s.length();//空指针异常
        (2) trim()：去掉前后的所有空格（包括Tab键空白符），中间的不会去掉，后期常用
        (3) equals：比较字符串的字符内容，严格区分大小写，==是比较对象地址
        (4) equalsIgnoreCase：比较字符串的字符内容，忽略大小写
        (5) isEmpty()：是否是空字符串
                 str == null  或  "".equals(str)  或  str.isEmpty()	//红色的方法最安全，因为不会报空指针异常，要是能确认非空就都可以用
        (6) toUpperCase()：转大写	//字符串一旦改变就换了对象了，应该拿一个变量接收一下，或者赋给自己，那他就变成大写了
        (7) toLowerCase()；转小写
        (8) s1.concat(s2)：和 s1+s2 相同都是拼接字符串，还涉及空指针问题，其他都一样
    二、字符串与字符字节相关
        (1) new String(char[] arr , 【int offset】, 【int count】)		//用arr的字符数组构建字符串，从下表offset开始一共count个,可不加后俩参数
        (2) char[] toCharArray()：   //把字符串转成字符数组		例 char[] arr = str.toCharArray()；
        (3) char charAt(index)： //获取字符串index位置的字符	例 char = input.next().chatAt(0);
        (4) byte[] getBytes(【Charset charset】或【String charsetName】)：  //byte[] bytes = str.getBytes("UTF-8");
        (5) String(byte[] bytes, 【int offset】, 【int length】, 【String charsetName】)：//指定的字符集解码的byte构造一新String 	//String string = new String(arr,0,4,"UTF-8");
    三、字符串操作
        (1) boolean endsWith(String suffix)： //测试此字符串是否以指定的后缀结束。 变量.endsWith("要查找的字符")
            boolean startsWith(String prefix, 【int toffset】)： //测试此字符串从[指定索引]开始的子字符串是否以指定前缀开始。
        (2) boolean contains(CharSequence s)： //当且仅当此字符串包含指定的 char 值序列时，返回 true。
        (3) int indexOf(int ch, 【int fromIndex】)： //返回在此字符串中第一次出现指定字符处的索引，[从指定的索引开始搜索]。无则但会‘-1’
            int indexOf(String str, 【int fromIndex】)： //返回指定子字符串在此字符串中第一次出现处的索引，[从指定的索引开始]。
            int lastIndexOf(int ch, 【int fromIndex】)： //返回指定字符在此字符串中最后一次出现处的索引，[从指定的索引处开始进行反向搜索]。
            int lastIndexOf(String str, 【int fromIndex】)： //返回指定子字符串在此字符串中最后一次出现处的索引，[从指定的索引开始反向搜索]。
        (4) String substring(int beginIndex, 【int endIndex】)： //返回一个新字符串，它是此字符串从beginIndex开始截取到【endIndex/最后】(不包含)的一个子字符串。
        (5) boolean matches(String regex)： //告知此字符串是否匹配给定的正则表达式。
        (6) String replace(char oldChar, char newChar)：  //（不支持正则）返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 。
            String replaceAll(String regex, String replacement)：  //（支持正则）使用给定的 replacement 替换此字符串所匹配给定的正则表达式的子字符串。
            String replaceFirst(String regex, String replacement)：  //（支持正则）使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。
        (7)String[] split(String regex, 【int limit】)：  //根据匹配给定的正则表达式来拆分此字符串，【最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中】。
5、Java的正则表达式
    一、常用语法(更全可看有道云笔记内容)
        "\\d"		    表示一个数字
        "\\d+"		    表示1-n个数字，其他类型也一样，有+号表示后边连续多个本成员
        "\\D"		    表示一个非数字
        "\\s"		    表示一个空白字符，多个就加+
        "\\S"		    表示一个非空白字符
        "\\w"		    表示一个单词字符，包括26个英文字母大小写下划线和0-9
        "\\W"		    表示非单词字符
        "^"			    表示开头
        "$"			    表示结尾
        "."			    匹配除"\r\n"之外的任何单个字符
        "+"             1~n个字符
        "*"             0~n个字符
        "?"             0~1个字符
        "[abc]"         字符集。匹配包含的任一字符
        "[^abc]"        反向字符集。匹配未包含的任何字符。例如，"[^abc]"匹配"plain"中"p"，"l"，"i"，"n"。
        "[^a-z]"        反向范围字符。匹配不在指定的范围内的任何字符。例如，"[^a-z]"匹配任何不在"a"到"z"范围内的任何字符。
        "x{n}"          表示字符x出现了n次
        "x{n,}"         表示字符x至少出现了n次
        "x{n,m}"         表示字符x至少出现了n次，最多m次
        "x|y"           匹配 x 或者 y
    二、练习
        "^|\\.\\[zk\\<\\].+\\[zk\\>\\]$"        匹配开头结尾：“zk<”开头“zk>”结尾
        "137|135\\d{8}"                         表示137或者135开头后边8个数字
6、可变字符串
    (1) StringBuffer(【int size】/【String str】)：   //构造指定【容量/内容】的字符串缓冲区
    (2) StringBuffer append(xx)： //提供了很多的append()方法，用于进行字符串拼接，“对象。append（“扩展内容”）”自动把原对象字符串串加一起，不用在接收了，要是想赋值给其他变量可以接受
    (3) StringBuffer delete(int start,int end)： //删除指定位置的内容
    (4) StringBuffer deleteCharAt(int index) ： //删除指定位置的字符
    (5) StringBuffer insert(int offset, xx)： //在指定位置插入xx
    (6) StringBuffer replace(int start, int end, String str)： //把[start,end)位置替换为str
    (7) StringBuffer reverse() ： //把当前字符序列逆转
    (8) void setCharAt(int index, char ch) ： //替换index位置的字符，该方法不支持方法链，因为方法的返回值类型是void
7、Math相关
    (1) abs                           //绝对值
    (2) PI 		                    //常量Π3.14159267.。。。。
    (3) acos,asin,atan,cos,sin,tan   //角函数
    (4) sqrt                         //平方根
    (5) pow(double a,doble b)        //a的b次幂
    (6) log                          //自然对数
    (7) exp                          //e为底指数
    (8) max(double a,double b)       //最大值
    (9) min(double a,double b)       //最小值
    (10) random()                    //返回0.0到1.0的随机数
    (11) long round(double a)        // double型数据a转换为long型（四舍五入）
    (12) double floor(double a) ：  //往小舍去小数点
    (13) double ceil(double a)  ：  //往大进一
    (14) toDegrees(double angrad)    //弧度—>角度
    (15) toRadians(double angdeg)    //角度—>弧度
    (16) BigInteger                 //可以表示不可变的任意精度的整数
    (17) BigDecimal                 //数字计算精度比较高，BigDecimal类支持不可变的、任意精度的符号十进制定点数。
8、System类
    (1)System.out：标准的输出设备，控制台
    (2)System.in：标准的输入设备，键盘
    (3)System.err：打印错误信息，默认用红色
    (4)System.currentTimeMillis()	获取系统时间
    (5)System.arraycopy(src, srcPos, dest, destPos, length);
    (6)System.exit(status);  终止当前正在运行的 Java 虚拟机。非0是异常终止，0是正常退出
    (7)System.gc()：通知垃圾回收器来回收垃圾
    (8)Properties getProperties()  ：获取当前系统的属性
9、日期类
    一、Date
        (1) date.getTime();	//获取当前毫秒值
    二、GregorianCalendar
        (1)Calendar c = Calendar.getInstance();	    //建对象
        (2)int year = c.get(Calendar.YEAR);         //取出时间对象Calendar的year，还可MONTH、DAY_OF_MONTH、HOUR_OF_DAY、SECOND等
        (3)c.set(Calendar.YEAR, 2018);              //设置时间对象Calendar的值
    三、java.text.DateFormat
        (1) SimpleDateFormat sf = new SimpleDateFormat("yyyy-MM-dd");   //创建实现类对象(指定格式)
        (2) String time = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS").format(new Date());   //返回目前时间的string
    四、java.time.LocalDate/LocalTime/LocalDateTime   不可改变日期类型
        (1) LocalDate jin = LocalDate.now();     //获取现在时间 2020-03-31
        (2) int year = jin.getYear();DayOfWeek dayOfWeek = jin.getDayOfWeek();      //获取具体值方法
        (3) LocalDate next = jin.plusMonths(3);     //三月后时间(也可jitianhou)
        (4) boolean b = jin.isLeapYear();           //是否是今年最后一天
    五、java.time.Instant/ZoneId/Duration/Period/format.DateTimeFormatter
        (1) Instant t = Instant.now();		//本初字母线时间
            OffsetDateTime atOffset = t.atOffset(ZoneOffset.ofHours(8));    //本初字母线偏移8小时时间
        (2) ZonedDateTime t = ZonedDateTime.now();  //现在的时区时间
            ZonedDateTime t1 = ZonedDateTime.now(ZoneId.of("America/New_York"));    //指定时区的时间
        (3) LocalDateTime t1 = LocalDateTime.now();
            LocalDateTime t2 = LocalDateTime.of(2018, 12, 31, 23, 59, 59, 999);
            Duration between = Duration.between(t1, t2);
            //Period between = Period.between(t1, t2);      //两种方法计算时间差
            between.toDays()；between.toHours()；     //计算时间差
        (4) DateTimeFormatter.ISO_DATE.format(LocalDate.now())          //格式化时间
            DateTimeFormatter.ISO_DATE_TIME.format(LocalDateTime.now()) //格式化时间
            DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL).format(LocalDate.now())     //FULL和SHORT适用于LocalDate和LocalTime
            DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT).format(LocalTime.now())    //FULL和SHORT适用于LocalDate和LocalTime
            DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM).format(LocalDateTime.now())   //LONG和MEDIUM适用于LocalDateTime
            DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now())      //格式化目前时间
10、File
    (1) 获取文件名：getName()	（传的路径名字拿走就留下文件名 “1.jpg”）
    (2) 获取文件的路径：getPath()    指定路径，new File对象时指定的路径，原样打印
	     获取文件的绝对路径：getAbsolutePath()   绝对路径，不会解析..等，（那个盘下全名，）
         ★获取文件的规范路径：getCanonicalPath()  绝对路径，会解析..等表示方式（那个盘下全名，）
	     获取父目录路径：getParent()		父目录路径就是传入的字符串路径名去掉文件名
    (3) 获取文件的大小：length()  单位字节   不能直接获取目录的大小，如果要获取，可以用递归
    (4) 获取文件最后修改时间：lastModified()  单位毫秒
    (5) 是否是文件：isFile()
        是否是目录：isDirectory()
        是否是隐藏：isHidden()
        是否存在：exists()
        是否可读：canRead
        是否可写：canWrite
    (6) 文件操作：
         * 1、创建：createNewFile，若目录不存在则没反应
         * 2、删除：delete()
         * 3、重命名：renameTo()	不能创建目录
         * 4、创建临时文件
               static File createTempFile(String prefix, String suffix)
               一般会配合void deleteOnExit()
    (7)目录的操作：
         * 1、创建
         * 		mkdir()  失败不报异常，如果父目录不存在，什么也不做
         * 		mkdirs() 如果父目录不存在，一并创建
         * 2、删除
         * 		delete()  删除的是最目录的最底层（而且只能删除空目录)，如果删除非空目录可以用递归
         * 3、重命名：
         * 		renameTo(xx)	xx位置可以更换位置，而且里边文件跟着移动，不能创建目录
         * 4、列出本目录下的子级
         * 		String[] list()
         * 		File[] listFiles()
11、IO流通用方法：
    一、字节输入流：InputStream
        （1）int read()：一次读一个字节，返回的读取的字节的值，如果到达数据末尾没有数据了就返回-1
        （2）int read(byte[] data)：一次读取多个字节，读取的数据存到data字节数组中，从[0]下标开始存储，返回实际读取的字节的个数，最多读data.length个，如果到达数据末尾没有数据了就返回-1
        （3）int read(byte[] data, int offset, int count)：：一次读取多个字节，读取的数据存到data字节数组中，从[offset]下标开始存储，返回实际读取的字节的个数，最多读取count个，没数据返回-1
        （4）void close():关闭IO流
    二、字节输出流：OutputStream
        （1）void write(int)：一次写一个字节
        （2）void write(byte[] data)：一次写整个字节数组
        （3）void write(byte[] data, int offset, int count)：一次写多个字节，从data[offset]开始，count个字节
        （4）void close():关闭IO流
        （5）void flush（）：刷新-从缓冲区立即写出
    三、字符输入流：Reader
        （1）int read()：一次读一个字符，返回的读取的字符的Unicode编码值，这个方法，如果流中没数据了，返回-1
        （2）int read(char[] data)：一次读取多个字符，读取的数据存到data字符数组中，从[0]下标开始存储，返回实际读取的字符的个数，最多读data.length个，这个方法，如果流中没数据了，返回-1
        （3）int read(char[] data, int offset, int count)：：一次读取多个字符，读取的数据存到data字符数组中，从[offset]下标开始存储，返回实际读取的字符的个数，最多读取count个，没数据返回-1
        （4）void close():关闭IO流
    四、字符输出流：Writer
        （1）void write(int)：一次写一个字符
        （2）void write(char[] data)：一次写整个字符数组
        （3）void write(char[] data, int offset, int count)：一次写多个字符，从data[offset]开始，count个字符
        （4）void write(String str)：字符串写出去
        （5）void write(String str, int offset, int count)：从offset写count这么长
        （6）void close():关闭IO流
        （7）void flush（）：刷新-从缓冲区立即写出
    五、常见IO
         （1）文件IO流
         * FileInputStream：以字节的方式读取文件内容
         * FileOutputStream：以字节的方式输出，保存文件内容
         * FileReader：以字符的方式读取纯文本文件内容
         * FileWriter：以字符的方式输出纯文本数据到纯文本文件中。
         （2）字节数组IO流
         * ByteArrayInputStream：从字节数组中读取数据
         * ByteArrayOutputStream：把数据保存到字节数组中
         （3）字符数组IO流
         * CharArrayReader：从字符数组中读取数据
         * CharArrayWriter：把数据保存到字符数组中
         * StringReader：从字符串中读取数据
         * StringWriter：把数据保存到字符串中
         （4）解码和编码IO流
         * OutputStreamWrite：//数据从程序 --> osw（字符流) -->按照编码-->fos（字节流)-->文件
         * InputStreamReader：//数据流向： "utf-8.txt" --> fis（字节流) --> isr（字符流))-->输出
         （5）缓冲IO流：
         * BufferedInputStream：给InputStream系列的IO流增加“缓冲”功能
         * BufferedOutputStream：给OutputStream系列的IO流增加“缓冲”功能
         * BufferedReader：给Reader系列的IO流增加“缓冲”功能
         * BufferedWriter：给Writer系列的IO流增加“缓冲”功能
         （6）对象IO流
         * ObjectInputStream：一次输入一个对象
         * ObjectOutputStream：一次输出一个对象
         （7）基本数据IO流
         * DataInputStream：一次输入一个Java的基本数据类型的值
         * DataOutputStream：一次输出一个Java的基本数据类型的值
         （8）打印流
         * PrintStream：例如：System.out
         * PrintWriter：例如：web中,response.getWriter() 给客户端输出数据用的
    六、DataInputStream / DataOutpuStream
        writeUTF(xx)	//String类型
        writeInt(xx)
        writeDouble(xx)
        writeChar(xx)
        writeBoolean(xx)
12、Thread / Runnable 多线程
    一、
13、Kafka
    一、producer
        (1) new KafkaProducer<String, String>(pro);  //创建生产者实例
        (2) producer.send( new ProducerRecord<String, String>(topicString, partition, key, value), 【new Callback(){***}】)  //发送消息：带回调函数
        (3) void onCompletion(RecordMetadata recordMetadata, Exception e)    //回调函数抽象方法(消息元数据，异常)
            recordMetadata.topic()； //回调函数中获取主题
            recordMetadata.offset()； //获取偏移量
            recordMetadata.partition()； //获取分区号
        (4) producer.close(); //关闭生产者
        (5) implements Partitioner    //自定义分区类
        (6) implements ProducerInterceptor<String, String>      //自定义Kafka拦截器
    二、consumer
        (1) new KafkaConsumer<String, String>(pros); //创建消费者实例
        (2) consumer.subscribe(Arrays.asList("first","second","third")); //设置消费者订阅那些topic
        (3) ConsumerRecords<String, String> records = consumer.poll(100);  //消费数据并返回
        (4) record.topic(); record.offset(); record.key(); record.value(); record.partition();      //获取主题、偏移量、分区、key、value
        (5) new SimpleConsumer(leader, 9092, 3000, 1024 * 1024, "消费数据");    //创建消费者
        (6) new FetchRequestBuilder().addFetch(topic, partition, offset, 1024 * 1024).build();  //封装获取数据的请求
        (7) FetchResponse fetchResponse = consumer.fetch(fetchRequest); //发送请求获取响应
        (8) fetchResponse.messageSet(topic, partition);     //筛选出指定topic和partition的响应集
        (9) messageAndOffset.offset(); //获取offset
        (10) messageAndOffset.message(); message.payload()get(new byte[payload.limit()]); new String(bytes); //将message解析成String

